<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
	<link type="text/css" href="mainstyles.css" rel="stylesheet">
</head>

<body>
<h1>1 Architektura a design</h1>

<h2><a name="IDE">1.1 Vıvojové prostøedí a pouité knihovny</a></h2>
	<p>Za cílovou platformu jsme pøedem zvolili systém Windows. Jednak proto, e nám byl všem dùvìrnì známı, jednak proto, e jsme nemìli ádné zkušenosti s grafickımi knihovnami OpenGL (narozdíl od DirectX), a koneènì proto, e vìtšina her urèená pro PC je smìøována na tento operaèní systém. Z dùvodu nìkterıch systémovıch funkcí jsme se navíc omezili na Windows XP, nebo Windows 98 a ME nemají podporu pøesnıch èasovaèù, kterıch je ve hrách tøeba, a Windows 2000 a 2003 jsme pøi vıvoji nemìli k dispozici pro stálé testování (navíc svım zamìøením nejsou vhodnou cílovou platformou).</p>
	<p>Z velmi obdobnıch dùvodù bylo pøi volbì programovacího jazyka vybráno C++. Pro své vlastnosti je to v dnešní dobì nejvíce pouívanı jazyk pøi vıvoji her, zvolili jsme ho tedy i my.</p>
	<p>Pøi vıbìru integrovaného vıvojového prostøedí (a potamo i kompilátoru) jsme povaovali Microsoft Visual Studio za jakısi standard, se kterım jsme navíc ji byli více èi ménì seznámeni. V prùbìhu vıvoje to pak byly postupnì verze 7.0, 7.1 a 8.0, respektive 2002, .NET 2003 a 2005. Narozdíl od jinıch vıvojovıch prostøedí urèenıch pro jazyk C++, MSVS zahrnuje debugger pro <a href="graphics.html#shaders">shadery</a>, co je nedocenitelná pomùcka pøi vıvoji grafickıch aplikací.</p>
	<p>Pro volbu grafickıch knihoven Direct3D pøispìl nejen to, e jsme s nimi mìli ji nìjaké zkušenosti, ale pøedevším fakt, e balík DirectX (jeho je Direct3D nedílnou souèástí) nezahrnuje pouze grafické knihovny, ale také zpracování uivatelského vstupu (modul DirectInput) a øadu dalších knihoven pro práci s hudbou, zvukem èi sítí (by jsme tyto další moduly v projektu nepouili).</p>
	<p>Po delším rozhodování jsme se také uchılili k pouití knihovny tøetí strany jako základ implementace fyzikálního enginu. Více o pouité knihovnì Newton Game Dynamics v sekci <a href="Physics.html">Fyzikální engine</a>.</p>
	<p>Pøehrávání hudby ze souborù formátu mp3 provádí funkce z knihovny <strong>FMOD</strong>.</p>
	
<h2><a name="projects">1.2 Hlavní moduly</a></h2>
	<p>Diagram na obr. 1.1 ukazuje závislosti mezi jednotlivımi moduly celého projektu. Do diagramu nejsou zahrnuty samostatné utility, které slouily jen pøi vıvoji a nejsou souèástí hry. Stejnì tak není v diagramu pro pøehlednost explicitnì zaznamenána závislost všech ostatních modulù na modulech <strong>Resource Manager</strong> a <strong>Globals</strong>. </p>
	<p class="center"><img src="images/ProjectDesign.gif"/></p>
	<p class="center"><strong>Obrázek 1.1: Diagram závislostí jednotlivıch modulù projektu. Pro pøehlednost nejsou zobrazeny závislosti všech modulù kromì Globals na Resource Manageru a všech modulù kromì Limited Editoru na modulu Globals.</strong></p>
	<h5><a name="Globals">Globals</a></h5>
		<p>Modul <strong>Globals</strong> má v projektu zcela zvláštní postavení. Zastøešuje všechna makra, konstanty, funkce a tøídy, které jsou široce pouívány ve všech ostatních modulech. Vytvoøení takto klíèového modulu má ten dùsledek, e samostatnì jsou ostatní moduly nepouitelné (nelze je pøenést a pouít v jiném projektu bez pøenesení Globals). Avšak jak u jsme se zmínili v úvodu - neplánovali jsme vytváøet knihovny obecnì pouitelnıch funkcí, ale jeden funkèní celek, a v takovém bylo vydìlení obecnì pouívanı entit ku prospìchu. Nejdùleitìjší funkcionalita tohoto modulu je popsána dále v kapitolách <a href="#config_files">Konfiguraèní soubory</a> a <a href="#error_handling">Ošetøování chyb a vıjimek</a>.</p>
		
	<h5><a name="ResMan">Resource Manager</a></h5>
		<p>Modulem, kterı se stará o správu zdrojù, je <strong>Resource Manager</strong>. Jednak je vrstvou oddìlující ostatní moduly od systému souborù, jednak se stará o to, aby ádnı soubor nebyl zbyteènì nahráván (èi dokonce uchováván v pamìti) vícekrát. Svım rozhraním poskytuje transparenci pøístupu k souborùm, take volající funkce nejen neví, z jakého místa byl poadovanı soubor naèten, ale ani zda byl vùbec právì naèten. Podstatné je pouze navrácené tzv. "resource ID" a struktura, která se dá za pomoci tohoto resrouce ID získat. Podrobnìji se Resource Manageru vìnujeme v sekci <a href="ResourceManager.html">Resource Manager</strong>.</p>
	
	<h5><a name="Main">Main</a></h5>
		<p>Modul <strong>Main</strong> je hlavním modulem projektu. Hlavním v tom smyslu, e jeho produktem je spustitelnı soubor, kterı startuje hru Unlimited Racer. Pomineme-li další samosatné aplikace, je tento modul pøímo èi nepøímo závislı na všech ostatních. Pøedstavuje øídící jednotku celé aplikace - "startuje" server i klienta, iniciuje grafickı mód atd. Více je moné nalézt v sekci <a href="hra.html#sec5">Hra</a>.</p>
	
	<h5><a name="Server">Server</a></h5>
		<p>Tento modul pøedstavuje serverovskou èást hry, tj. procesy, které jsou provádìny na serveru (a to i v pøípadì, e hráè zvolí hru typu "single player"). Je úzce svázán s moduly <strong>Physics</strong> a <strong>AI</strong>, jejich slueb vyuívá. Jeho souèástí je síové rozhraní, pøes které server komunikuje s klienty (pøijímá spojení, akceptuje hráèe, rozesílá údaje, ...). Bìhem samotné hry se stará o správnì probíhající vıpoèet fyzikálního modulu. Detailnìji je rozebrán v kapitole <a href="hra.html#sec5.2">Server</a>.</p>
	
	<h5><a name="Client">Client</a></h5>
		<p>Modul <strong>Client</strong> jednak pøedstavuje klientskou èást síové aplikace, tj. iniciuje spojení, ádá o slubu serveru (o vstup do hry) atd., jednak vystupuje jako prostøedník mezi serverem a hráèem - zpracovává uivatelskı vstup, pøedává ho serveru, naèítá a pøipravuje všechna data potøebná na stranì klienta a vyuíváním slueb modulù <strong>Graphic</strong> a <strong>Graphic Objects</strong> zajišuje zobrazení herní scény. Detailnìji je rozebrán v kapitole <a href="hra.html#sec5.1">Klient</a>.</p>
		
	<h5><a name="Physics">Physics</a></h5>
		<p>Serverem vyuívanı modul <strong>Physics</strong> má za úkol na základì vstupních dat, jimi jsou pøedzpracované uivatelské vstupy pøeloené do øeèi pøíkazù k ovládání auta (brdìní, plyn, toèení volantem, ...) a èasovı interval, urèit, jakım zpùsobem se scéna, nad kterou je vıpoèet provádìn, zmìní. To znamená, e objektùm udìlí rychlost, smìr pohybu, rotaci atd. Rozebrán je v samostatné sekci <a href="Physics.html">Physics</a>.</p>
	
	<h5><a name="Graphic">Graphic</a></h5>
		<p>Vıraznì nejrozsáhlejším modulem je <strong>Graphic</strong>, kterı zahrnuje øídící jádro 3D grafického engine, všechny jeho stìejní funkce a jeho souèástí je té systém ovládacích prvkù pøedstavujících neherní GUI. Modul je silnì závislı na modulu <strong>Graphic Objects</strong>, je by se dal povaovat za jeho datovou èást. Velmi detailnì jsou oba moduly rozebrány v sekci <a href="graphics.html">Grafickı engine</a>, odkud je také více pochopitelnı jejich tìsnı vztah.</p>
	
	<h5><a name="GrObjects">Graphic Objects</a></h5>
		<p>Modul <strong>Graphic Objects</strong> reprezentuje zobrazovanou scénu, je tedy vyuíván pøednì modulem <strong>Client</strong> pro naètení a správu celé herní scény, a pak modulem <strong>Graphic</strong> jako jednotka zobrazující ádaná data zvolenım zpùsobem. Dopodrobna je rozebrán v kapitole <a href="graphics.html#graphicobjects">Grafické objekty</strong> sekce <a href="graphics.html">Grafickı engine</strong>, jeho je nedìlitelnou souèástí.</p>
	
	<h5><a name="Editor">Limited Editor</a></h5>
		<p><strong>Limited Editor</strong> je samostatnou okenní aplikací slouící k vytváøení a editování tratí (a nejen tratí), které je moné následnì uplatnit ve høe. Je závislı pouze na <strong>Resource Manageru</strong>, kterı nevyuívá ani tak pro inteligentní správu zdrojù, jako spíše pro naèítání všech relevantních typù souborù. Rozebrán je v sekci <a href="limitededitor.html">Limited Editor</a>.</p>
		
	<h5><a name="AI">AI</a></h5>
		<p>Ve høe je moné soutìit s fiktivními oponenty, co jsou poèítaèem øízená auta. Modul <strong>AI</strong> (tj. Artificial Intelligence) pøedstavuje rozhodovací logiku tìchto oponentù. Na základì znalosti vlastností auta a okolní scény se rozhoduje jakım zpùsobem auto dále øídit. Tento proces je øízen serverem, stejnì jako fyzikální vıpoèet. Více je moné nalézt v sekci <a href="AI.html">AI</a>.</p>
	
	<h5><a name="others">Další moduly</a></h5>
		<p>Projekt zahrnuje ještì øadu dalších modulù (celkem 19), které byly v prùbìhu vıvoje vyuívány pøedevším ke generování èi editaci nìkterıch dat a k snadnému testování jinıch modulù. Nìkteré však ji ztratily vıznam docela kvùli zmìnì formátu souborù, èi pøímo zmìnì návrhu a chování jinıch èástí projektu. Dùleité a stále aktivní projekty jsou tyto:</p>
		<ul>
			<li><strong>Terrain Generator</strong> - aplikace pouívaná na generování plátù terénu. Více viz kapitola TODO LINK.</li>
			<li><strong>Graphic Test</strong> - aplikace pouívaná na testování funkcí grafického engine (jednodušší a rychlejší testování ne ve høe).</li>
			<li><strong>Script Interpreter</strong> - knihovna slouící jako interpret námi definovaného skriptovacího jazyka. Pouívána pøednì moduly <strong>Graphic Test</strong> a <strong>Terrain Generator</strong>. Více v kapitole TODO LINK.</li>
			<li><strong>Setup Wizard</strong> - vıstupem tohoto modulu je tradièní instalátor pro Windows, kterı nainstaluje na cílovı poèítaè Unlimited Racer, Limited Editor a všechny potøebné knihovny.</li>
		</ul>

<h2><a name="directories">1.3 Adresáøová struktura</a></h2>
	<p>Pro lepší orientaci v (nejen) zdrojovıch souborech projektu zde lehce okomentujeme adresáøovou strukturu. Všechny uvedené cesty jsou relativní ke koøenovému adresáøi projektu.</p>
	<table border=1>
		<thead><tr><td>Relativní cesta</td><td>Popis adresáøe</td></tr></thead>
		<tbody>
			<tr><td><strong>.</strong></td><td>Koøenovı adresáø obsahuje pouze projektové soubory pro MSVS 2005.</td></tr>
			<tr><td><strong>AI\</strong></td><td>Zdrojové soubory modulu <a href="AI.html">AI</a>.</td></tr>
			<tr><td><strong>BBModeler\</strong></td><td>Zdrojové soubory ji nepouívaného modulu na editaci obálek <strong>BB Modeler</strong>.</td></tr>
			<tr><td><strong>BBParser\</strong></td><td>Zdrojové soubory ji nepouívaného modulu na generování obálek <strong>BB Parser</strong>.</td></tr>
			<tr><td><strong>Client\</strong></td><td>Zdrojové soubory modulu <a href="hra.html#Sec5.1">Client</a>.</td></tr>
			<tr><td><strong>compilation\</strong></td><td>Vıstupní soubory modulù, jejich vısledkem je spustitelná aplikace nebo dynamicky linkované knihovna. Té koøenovı adresáø vıstupní adresáøové struktury tvoøené instalátorem.</td></tr>
			<tr><td><strong>compilation\Data\</strong></td><td>Adresáø se všemi datovımi soubory pro hru. Detailnìjší rozebrání tohoto adresáøe je moné nalézt v <a href="FileSystem.html">dokumentaci souborového systému</a>.</td></tr>
			<tr><td><strong>compilation\Data\Shaders\</strong></td><td>Adresáø souborù obsahujících vertex a pixel shadery.</td></tr>
			<tr><td><strong>compilation\linking\</strong></td><td>Koøenovı adresáø pro vıstupní soubory modulù, jejich vısledkem je statická knihovna (té tedy zvláštní cesta pro linker). Adresáø je dále dìlen do podadresáøù podle oznaèení kompilace (debug/release/...).</td></tr>
			<tr><td><strong>compilation\removable\</strong></td><td>Odkládací adresáø pro doèasné soubory kompilátoru (prekompilované headery atd.). Adresáø je dále dìlen do podadresáøù podle oznaèení kompilace (debug/release/...).</td></tr>
			<tr><td><strong>compilation\Support\</strong></td><td>Obsahuje dokumentaci projektu, manuál a další pøiloené dokumenty.</td></tr>
			<tr><td><strong>DXSetup\</strong></td><td>Obsahuje instalátor potøebné verze DirectX. Tento balík je pøidáván do instalátoru jako volitelnı krok po instalaci hry.</td></tr>
			<tr><td><strong>DXUtils\</strong></td><td>Zdrojové soubory starší verze rozšiøujících funkcí Direct3D pro zobrazování textu na obrazovku.</td></tr>
			<tr><td><strong>FMOD\inc\</strong></td><td>Hlavièkové soubory knihovny FMOD Ex pouívané pro pøehrávání hudby ve høe.</td></tr>
			<tr><td><strong>FMOD\lib\</strong></td><td>Staticky llinkované knihovny modulu FMOD Ex pouívaného pro pøehrávání hudby ve høe.</td></tr>
			<tr><td><strong>Globals\</strong></td><td>Zdrojové soubory modulu <strong>Globals</strong>.</td></tr>
			<tr><td><strong>Graphic\</strong></td><td>Zdrojové soubory modulu <a href="graphics.html">Graphic</a>.</td></tr>
			<tr><td><strong>GraphicObjects\</strong></td><td>Zdrojové soubory modulu <a href="graphics.html#graphicobjects">Graphic Objects</a>.</td></tr>
			<tr><td><strong>GraphicTest\</strong></td><td>Zdrojové soubory modulu <strong>Graphic Test</strong>.</td></tr>
			<tr><td><strong>LODGenerator\</strong></td><td>Zdrojové soubory ji nepouívaného modulu <strong>LOD Generator</strong>.</td></tr>
			<tr><td><strong>Main\</strong></td><td>Zdrojové soubory modulu <a href="hra.html">Main</a>.</td></tr>
			<tr><td><strong>MapEditor\</strong></td><td>Zdrojové soubory modulu <a href="limitededitor.html">Limited Editor</a>.</td></tr>
			<tr><td><strong>ModelMaker\</strong></td><td>Zdrojové soubory ji nepouívaného modulu <strong>Model Maker</strong> urèeného k vytváøení balíkù datovıch souborù.</td></tr>
			<tr><td><strong>NewtonSDK\</strong></td><td>Koøenovı adresáø SDK pouitého modulu Newton Game Dynamics.</td></tr>
			<tr><td><strong>Physics\</strong></td><td>Zdrojové soubory modulu <a href="Physics.html">Physics</a>.</td></tr>
			<tr><td><strong>ResourceManager\</strong></td><td>Zdrojové soubory modulu <a href="others.html#ResourceManager">Resource Manager</a>.</td></tr>
			<tr><td><strong>RMTest\</strong></td><td>Zdrojové soubory ji nepouívaného modulu <strong>RM Test</strong> urèeného pro testování Resource Manageru.</td></tr>
			<tr><td><strong>ScriptInterpreter\</strong></td><td>Zdrojové soubory modulu <a href="others.html#ScriptInterpreter">Script Interpreter</a>.</td></tr>
			<tr><td><strong>Server\</strong></td><td>Zdrojové soubory modulu <a href="hra.html#Sec5.2">Server</a>.</td></tr>
			<tr><td><strong>SetupWizard\</strong></td><td>Projektové soubory obsahující konfiguraci instalaèního modulu <strong>Setup Wizard</strong>.</td></tr>
			<tr><td><strong>SetupWizard\Release\</strong></td><td>Vıstupní soubory instalaèního modulu Setup Wizard - instalaèní balík hry.</td></tr>
			<tr><td><strong>TerrainGenerator\</strong></td><td>Zdrojové soubory modulu <a href="others.html#TerrainGenerator">Terrain Generator</a>.</td></tr>
		</tbody>
	</table>

<h2><a name="error_handling">1.4 Ošetøování chyb a vıjimek</a></h2>
	<p>V projektu jsme se namísto standardních vıjimek rozhodli navrhnout jinı systém zachytávání a ošetøování vzniklıch chyb, kterı by více splòoval naše poadavky:</p>
	<ol>
		<li>Nezávislost na zpùsobu prezentování chyby.</li>
		<li>Snadné dohledávání pùvodu chyby pro úèely ladìní.</li>
		<li>Jednoduché pouití.</li>
	</ol>
	<p>Jednotlivé body jsou uvedeny víceménì v poøadí dùleitosti. V první øadì jsme hledali zpùsob, jak navrhnout systém hlášení chyb tak, aby mohly bıt chyby uivateli prezentovány libovolnım zpùsobem podle typu aplikace (ve høe bude tøeba chyby ohlašovat jinak ne v okenní aplikaci jakou je napøíklad editor tratí). Tím bylo dáno, e o prezentaci chyby se nesmí starat chybovı mechanismus sám, ale musí se o ni postarat bìící aplikace, které bude oznámeno, jaká chyba nastala. Pøitom však jsme chtìli, aby bylo moné chybu vyvolat kdekoli, tedy i v modulu mimo aplikaci. To nás dovedlo k implementaci pomocí callback funkce, tj. funkce, kterou hlavní modul aplikace zaregistruje ve tøídì systému hlášení chyb, a ta zaregistrovanou funkci následnì volá pøi kadé vzniklé chybì. Parametrem jí pøitom pøedává text chyby a místo, ve kterém k chybì došlo.</p>
	<p>To, e kadá vzniklá chyba udává místo, kde k ní došlo, je zásadní pøedevším pro ladící úèely. Chybu toti neošetøuje (nehlásí) pouze jedna funkce, jako tomu bìnì bıvá v pøípadì vıjimek. Vìtšinu funkcí a metod tøíd jsme napsali tak, e vrací chybovou hodnotu v podobì promìnné typu <strong>HRESULT</strong>, co je celoèíselná hodnota chápána tak, e 0 znamená úspìšné provedení funkce a záporná hodnota reprezentuje definovanı kód chyby (kladné hodnoty jsou zpravidla nevyuity). Kadé volání takové funkce je tedy otestováno a v pøípadì, e došlo k chybì, je vygenerována chybová hláška. Bìh volající funkce je zpravidla v daném místì ukonèen s návratovou hodnotou oznamující chybu. Tato chyba však ji mùe bıt jiného charakteru, nebo volající funkce chápe nastalou situaci jinak. Pøíkladem je chyba vzniklá v Resource Manageru, kterému se nepodaøilo otevøít poadovanı soubor. Resource Manager vygeneruje chybovou hlášku pro chybu <strong>ERRFILENOTFOUND</strong> a oznámí chybu volající funkci. Ta nezjišuje k jaké chybì došlo uvnitø Resource Manageru, z jejího pohledu pouze došlo k tomu, e poadovanı zdroj nebyl k dispozici, co mohlo vést øeknìme k neúspìšné inicializaci jednoho z aut hráèù. V takovém pøípadì funkce oznámí chybu <strong>ERRRESOURCENOTAVAILABLE</strong> a pøedá øízení funkci nadøazené. Schéma na obr. 2 zachycuje popsanı princip.</p>
	<p class="center"><img src="images/ErrorHandling.gif"/></p>
	<p class="center"><strong>Obrázek 2: Schéma zachytávání chyb.</strong></p>
	<p>Uvedené øešení nám znaènì zjednodušilo dohledávání chyb v kódu, nebo všechny chybové vıstupy jsme nasmìøovali do souboru, kterı pøi vzniku nìjaké chyby obsahoval záznamy o tom, kde byla chyba vyvolána, co bylo její podstatou, ale pøedevším jakou hierarchií volání jsme se k ní dostali. Tak jsme mohli èasto i bez pouití debuggeru rozpoznat kde v programu se nachází chyba. Pøíklad chybového vıstupu mùe bıt následující:</p>
	<pre>  CResourceManager::LoadPhysicalTexture() : Can not find file 'GRASS.PHPLATE'. 
  CResourceManager::LoadResource() : Could not load PhysicalTexture.
  CResourceManager::LoadTerrain() : Could not load PhysicalTexture 'grass.phPlate'.
  CResourceManager::LoadResource() : Could not load Terrain.
  CGrObjectTerrain::Init() : Could not load terrain object.
  MapInit() : Terrain wasn't loaded</pre>
	<p>Na prvním øádku v uvedeném chybovém vıstupu se dozvídáme, e nebyl nalezen potøebnı soubor, v dalších øádcích pak kde v programu byl tento soubor poadován.</p>
	<p>Vylepšením tohoto systému je rozdìlení hlášek na ryze chybové (zpravidla ukonèí program) a hlášky ladícího charakteru (upozoròují na to, kudy program prošel, pøípadnì jaké podezøelé hodnoty se nachází v nìkterıch dùleitıch promìnnıch). Pro kadı typ hlášek je samostatnı objekt se svou vlastní funkcí pro smìrování vıstupu, take zatímco chybové hlášky mohou bıt smìøovány do souboru, ladící hlášky mùeme zobrazovat na obrazovku atp. Pro ladící hlášky je navíc definováno 5 úrovní dùleitosti a nastavením makra èi promìnné <strong>DebugLevel</strong> je moné ovlivòovat jak podrobné (a tedy i objemné) mají bıt ladící informace.</p>
	<p>Pod pojmem jednoduché pouití jsme si pøedstavovali vyhnutí se psaní nadbyteèného kódu jen pro ošetøování chyb. Tomu jsme tolik nedostáli, a proto jsme nadefinovali celou øadu maker, která tuto nevıhodu potlaèovala. Následující pøíklad ukazuje ošetøení vytvoøení dynamické promìnné jako pole a její následné uvolnìní.</p>
	<pre>  // definice uitıch maker
  #define ERRORMSG(code, location, param, ret)    \
                {    \
                    ErrorHandler.HandleError( code, _T( location ), _T( param ) );    \
                    return ret;     \
                }
  #define ERRORMSG(code, location, param)  __ERRORMSG(code, location, param, code)
  #define SAFE_NEW(p,_class,fce)  { p=new (_class); if(!p)ERRORMSG(ERROUTOFMEMORY,fce,""); }
  #define SAFE_NEW_ARRAY(p,_class,size,fce)	SAFE_NEW(p,_class[size],fce)
  #define SAFE_DELETE_ARRAY(p)  { if (p) { delete[] (p); (p) = NULL; } }
  
  // definice funkce, která naalokuje a dealokuje pole
  // v pøípadì chyby vyvolá chybovou hlášku a vrátí nenulu
  HRESULT CClass::Foo( int count ) {
      CClassItem * pArray;
      
      SAFE_NEW_ARRAY(pArray,CClassExample,count,"CClass::Foo()")
      /* ...  pouití pole pObject ... */
      SAFE_DELETE_ARRAY(pObject)
      return ERRNOERROR;
  }</pre>

<h2><a name="config_files">1.5 Konfiguraèní soubory</a></h2>
	<p>Ji bylo zmínìno, e jednou z našich hlavních snah je nabídnout uivateli (hráèi) co nejvìtší vlastní prostor, co nejširší pole pùsobnosti na úrovni konfigurace a tvorby map, terénù a objektù ve høe. K uskuteènìní našich pøedstav je nutné mít buïto velmi silné editaèní nástroje, nebo dobøe pøístupná data mìnitelná uivatelem. Dostateènì obecnı editor pro všechny moné typy datovıch souborù pouívanıch ve høe by byl jednak pøíliš rozsáhlı projekt, ne abychom byli schopni jej zahrnout do našeho èasového harmonogramu, jednak by neustále naráel na zmìny, které jsme provádìli v prùbìhu dosavadního vıvoje èi které pøinese další vıvoj a rozšiøování schopností herního enginu. Proto jsme se rozhodli pro druhou variantu, tj. systém konfiguraèních souborù volnì pøístupnıch uivateli.</p>
	<p>Navrhli jsme syntaxi obecného konfiguraèního souboru, kterı má slouit k nastavení pojmenovanıch poloek. Pøi návrhu jsme vyšli ze standardních .ini souborù, ve kterıch jedna øádka odpovídá jednomu pøiøazení (nastavení promìnné) a ve kterıch je moné definovat návìští oznaèující blok pøiøazení urèitého charakteru. V prùbìhu vıvoje se však ukázalo, e by bylo uiteèné moci definovat hierarchickou strukturu. Rozhodli jsme se tedy o pøidání druhé moné syntaxe, ve které jsou namísto návìští párové závorky (tagy) uzavírající skupinu pøiøazení z obou stran (tedy platnost tagu nekonèí definicí následujícího tagu jako v pøípadì návìští). Obì syntaxe je moné míchat v rámci jednoho souboru, ale nikde se toho nevyuívá.</p>
	<p>Shrneme-li obecnou syntaxi tìchto souborù do krátkého pøehledu, pak v kadém souboru je moné pouít:</p>
	<ul>
		<li>pojmenované návìští definované pomocí hranatıch závorek
			<pre>  [PojmenovaneNavesti]</pre>
		</li>
		<li>párovı tag pomocí špièatıch závorek
			<pre>  &lt;LibovolnyTag&gt;
  &lt;/LibovolnyTag&gt;</pre>
		</li>
		<li>párovı tag uvnitø jiného tagu
			<pre>  &lt;LibovolnyTag&gt;
    &lt;VnorenyTag&gt;
    &lt;/VnorenyTag&gt;
  &lt;/LibovolnyTag&gt;</pre>
		</li>
		<li>pøiøazení textu nìjaké pojmenované poloce (okolní "whitespace" se ignoruje)
			<pre>  JmenoPolozky = Text, ktery chceme polozce priradit.</pre>
		</li>
		<li>pøiøazení celého èísla nìjaké pojmenované poloce (reprezentováno pomocí 32 bitù)
			<pre>  CelociselnaPolozka = 987654321
  JinaPolozka = 0xffa0a0a0</pre>
		</li>
		<li>pøiøazení "reálného" èísla nìjaké pojmenované poloce (èíslo s plovoucí øádovou èárkou uchováno v 32 bitech)
			<pre>  RealnaPolozka = 3.141592</pre>
		</li>
		<li>komentáø platnı od znaku støedník a do konce øádky
			<pre>  Polozka = 123 ; krátkı komentáø k poloce
  ; na další øádce jej musíme uvodit znovu</pre>				
		</li>
	</ul>
	<p>K syntaxi je tøeba doplnit, e z kadého øádku je naèteno pouze prvních 512 znakù, ostatní jsou zahozeny. Maximální délka jména poloky, tagu èi návìští není definována, ale logicky té nemùe pøesáhnout 512 znakù.</p>
	<p>Implementaènì je naèítání konfiguraèního souboru øešeno metodou <strong>Load()</strong> tøídy <strong>NAMEVALUEPAIR</strong>. Metodì je pøedána callback funkce, která je následnì volána pro kadı naètenı relevantní øádek zvoleného konfiguraèního souboru (jsou tedy ignorovány prázdné øádky a øádky obsahující pouze komentáø). Metoda <strong>Load()</strong> pøedem urèí, jakého typu je naèítanı øádek (zda je to specifikace poloky, návìští nebo otevírající èi uzavírající tag) a callback funkci pøedá informaci o typu, jménu a hodnotì daného øádku (hodnota je nastavena pouze pro specifikaci poloky, návìští a tagy mají definováno jen jméno). Je na volajícím, resp. pøedané callback funkci, aby zpracoval naètené poloky. Pokud dojde pøi naèítání k chybì na stranì zpracovávající callback funkce (kupøíkladu je zadání nìkteré poloky odporuje pravidlùm daného konfiguraèního souboru), je o tom spravena i metoda <strong>Load()</strong>, která ukonèí další zpracování souboru.</p>
	<p>Vıhodou tìchto konfiguraèích souborù je snadná specifikace nového typu vstupních dat, jednoduché zvládnutí syntaxe pro uivatele a mimo jiné i to, e umoòuje zadávat libovolnou poloku opakovanì (naopak v pøípadì, e je potøeba opakované zadávání poloek potlaèit, je nutné toto zaøídit vnitøními stavy na úrovni volané callback funkce).</p>
	
	
</body>
</html>