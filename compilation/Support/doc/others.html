<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
<link type="text/css" href="mainstyles.css" rel="stylesheet">
</head>

<body>

<h1><a name="sec7">7 Další moduly</a></h1>

<h2><a name="ResourceManager">7.1 Resource Manager</a></h2>
	<p>Resource Manager (dále jen RM) zajišuje nahrávání a správu dat pouívanıch v Unlimited Raceru a Limited Editoru. Umoòuje ostatním èástem projektu pøístup k nahranım datùm, zabraòuje opakovanému nahrávání stejnıch dat a uvolòuje nahraná data v pøípadì, e ji nejsou pro bìh programu potøebná. Dále poèítá kontrolní souèty (CRC) vybranıch dat, aby byla zajištìna jejich kompatibilita pøi síové høe. RM vyuívá globální sluby z projektu <strong>Globals</strong>.</p>
	<p class="center"><img src="images\RMClasses.gif" /></p>
	<p class="center"><strong>Obrázek 7.1: Schéma tøíd v RM.</strong></p>

	<h3><a name="sec7.1.1">7.1.1 CResourceManager</a></h3>
	
	<p><code>CResourceManager</code> je základní tøída zapouzdøující celı RM, pøes kterou probíhá veškerá komunkace s ostatními èástmi programu. Obsahuje funkce pro nahrávání, uvolòování a správu dat, dále pak funkce pro získávání nahranıch dat a jejich CRC souètù. U nahranıch dat si RM pamatuje reference count, tedy kolikrát byla data nahrána. Díky tomu je moné se vyhnout opakovanému nahrávání stejnıch dat a uchovávat jednou nahraná data v pamìti tak dlouho jak je potøeba. K nahrávání dat se pouívá funkce <code>LoadResource</code>. Její návratovou hodnotou je unikátní <code>RESOURCEID</code>, které jednoznaènì identifikuje nahraná data a slouí k jejich pøístupu pøes funkce <code>GetResource</code> pøípadnì <code>GetXXX</code>, kde <code>XXX</code> je jméno datového typu pouívaného v RM (napøíklad <code>Texture</code>, <code>Map</code>, <code>XFile</code>, <code>VertexShader</code>, ... a další). V souèasné dobì umoòuje RM nahrávat pøiblinì 30 rùznıch typù dat. Data se uvolòují funkcí <code>ReleaseResource</code>, pøièem platí, e kadému volání funkce <code>LoadResource</code> musí odpovídat právì jedno volání funkce <code>ReleaseResource</code>. Po nahrátí datového typu se pomocí tøídy <a href="#sec7.1.4"><code>CCrc32Static</code></a> spoèítá jeho kontrolní souèet (CRC). Ten se poté pouije v projektu <strong>Server</strong> pro kontrolu, zda všichni klienti i server pouívají stejnou mapu, stejné objekty atd. </p>
	<p>Nahraná data jsou "obalena" tøídou <a href="#sec7.1.2"> <code>CResourceContainer</code></a> a spolu s informacemi o datech (struktura <code>ResourceInfo</code>) jsou uchována ve dvou hash tabulkách:</p>
	<pre>
  CReferenceVector < RESOURCEID, CResourceContainer > * DataHashTable;
  CReferenceVector < CAtlString, ResourceInfo       > * ResourceInfoHashTable;</pre>
	<p>Velikost hash tabulek lze nastavit pøi inicializaci RM, Reference counter a kolize v tabulkách jsou øešeny pomocí šablony <a href="#sec7.1.3"> <code>CReferenceVector</code></a>.</p>

	<h3><a name="sec7.1.2">7.1.2 CResourceContainer</a></h3>
	<p>Tøída <code>CResourceContainer</code> se pouívá pro zapouzdøení jednotlivıch datovıch typù nahrávanıch pomocí RM a jejich uloení v jednotné struktuøe. Obsahuje <code>union</code> všech datovıch typù pro co nejmenší velikost. Její destruktor se stará o správné uvolnìní nahranıch dat, vèetnì tzv. Inherited Resources. Inherited Resources jsou data nahrávaná v rámci nahrávání jinıch dat. Pøíkladem mùe bıt typ <code>XFile</code>, kterı obsahuje 3d model objektu a textury na nìm pouité. V rámci jeho nahrávání se tedy nahraje i nìkolik textur (typ <code>Texture</code>) a jejich <code>RESOURCEID</code> se uloí v datové struktuøe typu <code>XFile</code>.</p>

	<h3><a name="sec7.1.3">7.1.3 CReferenceVector</a></h3>
	<p>Pùvodnì se pro øešení kolizí pouívala šablona tøídy <code>CBinaryTree</code>. Obsahovala plnì funkèní implementaci bináního stromu s automatickım vyvaováním. Pouití hiearchické stromové struktury se pozdìji ukázalo bıt velmi nešastné. Náš systém závislostí nahrávanıch dat na jinıch datech (Inherited Resources), spolu s dalšími vlastnostmi systému ukládání dat, zpùsoboval velké problémy pøi uvolòování dat, které ve speciálních pøípadech vedly a k rozpadu celého binárního stromu. Tato chyba se navíc zaèala plnì projevovat a pøi dostateèném poètu nahrávanıch dat. V dobì odhalení bylo ji nemoné jakkoliv mìnit filozofii nahrávání dat a proto bylo nutné šablonu <code>CBinaryTree</code> nahradit jinou šablonou se stejnou funkèností a stejnım rozhraním - tou je <code>CReferenceVector</code>.</p>
	
	<p><code>CReferenceVector</code> je šablona pro øešení kolizí hash tabulek pouitıch v tøídì <a href="#sec7.1.1"><code>CResourceManager</code></a>. Šablona je parametrizována dvìma typy - <code>Key</code> a <code>Value</code>. <code>Key</code> je klíèem dat, pouívá se k jejich identifikaci a seøazení, <code>Value</code> jsou potom samotná data. Trojice [<code>Key</code>, <code>Value</code>, reference counter] je uloena v šablonì STL <code>vector</code>, navíc je seøazená podle klíèe <code>Key</code> pro rychlejší vyhledávání. Pøi pokusu o pøidání nového prvku s klíèem, kterı je shodnı s klíèem prvku, kterı je zde ji uloen, se u uloeného prvku zvıší reference counter o 1. Analogicky se pøi odebírání prvku s takovım klíèem sníí reference counter uloeného prvku o 1. Pokud je po tomto sníení reference counter rovnı 0, prvek se odstraní z vectoru a uvolní z pamìti.</p>
	<p>Kromì funkcí na pøidání a odebrání prvku obsahuje šablona také funkci na zjištìní hodnoty <code>Value</code> asociované s klíèem <code>Key</code> a další funkce, které pouívá RM.</p>

	<h3><a name="sec7.1.4">7.1.4 CCrc32Static</a></h3>
	<p><code>CCrc32Static</code> je third-party tøída pro vıpoèet CRC souborù. Obsahuje nìkolik statickıch funkcí pro vıpoèet CRC, RM pouívá funkci FileCrc32Win3(). Více informací o této tøídì (vèetnì zdrojovıch kódù) lze najít na adrese <a href="http://cgdev.iworld.com/Cpp/Cpp/algorithms/checksum/article.php/c5103/" target="_blank">http://cgdev.iworld.com/Cpp/Cpp/algorithms/checksum/article.php/c5103/</a>.</p>
	<h3><a name="sec7.1.5">7.1.5 Pøidání nového typu dat do RM</a></h3>
	<p>Pro usnadnìní pøidávání novıch typù dat do RM byla na mnoha místech pouita makra. Tato makra velmi zjednodušují pøidávání novıch typù dat, ale pomìrnì dost znesnadòují ètení a ladìní kódu, proto zde uvedeme jejich popis. Hlavní myšlenka tìchto maker je jednoduchá - proè pøidávat novı typ na nìkolik míst (a potenciálnì na nìkteré z nich zapomenout), kdy ho lze pøidat všechny automaticky? K tomu se pouívá makro <code>EXPAND</code>:</p>
	<pre>    #define EXPAND(WHAT) \
    WHAT( Typ1  )\
    WHAT( Typ2  )\
    WHAT( Typ3  )\
    ...
    WHAT( TypN  )</pre>
  <p>Parametrem toho makra, je makro <code>WHAT</code>. <code>EXPAND(WHAT)</code> se tedy rozepíše na posloupnost maker <code>WHAT</code> aplikovanıch na jednotlivé datové typy. Toho se vyuívá k zapsání opakujících se èástí kódu, kde figurují jednotlivé datové typy. Zde je pár pøíkladù:</p>
    <pre>    typedef struct __Typ1 {
    /* data typu 1 */
    } Typ1;
        
    typedef struct __Typ2 {
    /* data typu 2 */
    } Typ2;

    ...

    typedef struct __TypN {
    /* data typu N */
    } TypN;

    #define RESOURCE_DATA_DECLARATOR(TYPE)   TYPE _##TYPE;

    typedef union __ResourceData {
        EXPAND(RESOURCE_DATA_DECLARATOR)
    } ResourceData;</pre>
	<p>Tento kus kódu bude po zpracování preprocesorem:</p>
<pre>    typedef struct __Typ1 {
    /* data typu 1 */
    } Typ1;
        
    typedef struct __Typ2 {
    /* data typu 2 */
    } Typ2;

    ...

    typedef struct __TypN {
    /* data typu N */
    } TypN;

    typedef union __ResourceData {
    	Typ1 _Typ1;
    	Typ1 _Typ2;
	...
    	Typ1 _TypN;
    } ResourceData;</pre>
	<p>Podobnì je makro <code>EXPAND</code> pouito i na dalších místech.</p>
	<p>Pro pøidání nového typu je nutné:</p>
	<ul>
		<li>
			V souboru <code>RMDataStructs.h</code>  pøiøadit novému typu identifikaèní èíslo, napøíklad:<br>
			<pre>#define RES_ZatimPosledniTyp   28
#define RES_NovyTyp            29
#define RESOURCE_CNT           30</pre>
		</li>
		<br>
		<li>
			V souboru <code>RMDataStructs.h</code> nastavit, zda se má pro novı datovı typ poèítat CRC:<br>
<pre>const bool bCheckResourceCRC[RESOURCE_CNT] = \
    false, /* RES_NoType           */\
    true , /* RES_Typ1             */\
    false, /* RES_Typ2             */\
    ...
    true , /* RES_ZatimPosledniTyp */\
    false, /* RES_NovyTyp          */\
};</pre>
		</li>
		<br>
		<li>
			V souboru <code>RMDataStructs.h</code> pøidat novı typ do definice makra <code>EXPAND</code>, napøíklad:
<pre>WHAT( ZatimPosledniTyp )\
WHAT( NovyTyp          )</pre>
		</li>
		<br>
		<li>
			V souboru <code>RMDataStructs.h</code> pøidat definici jména nového typu, napøíklad:<br>
<pre>#define RES_NAME_ZatimPosledniTyp  "ZatimPosledniTyp"
#define RES_NAME_NovyTyp           "TextureSet"</pre>
		</li>
		<br>
		<li>
			V souboru <code>RMDataStructs.h</code> pøidat novou datovou strukturu k novému typu. Tato struktura musí mít unifikovanou deklaraci v tomto formátu:<br>
			<pre>typedef struct __NovyTyp {
/* data noveho typu */
} NovyTyp;</pre>
			Struktura <code>__NovyTyp</code> nesmí obsahovat instanci tøídy, mùe však obsahovat ukazatel na ní. Pokud by ji obsahovala, vytvoøil by se pro strukturu <code>__NovyTyp</code> konstruktor, kterı je ovšem nepøípustnı díky pouití této struktury v unionu <code>__ResourceData</code>.
		</li>
		<br>
		<li>
			Pøidat novou funkci naèítací funkci do souboru <code>LoadResource.cpp</code>. Tato funkce by mìla pouít unifikovanou hlavièku, respektovat nastavení nahrávání <code>bInheritedResources</code> a pøidat všechny takto naètené datové typy do vektoru <code>pvInheritedResources</code>, napøíklad:
<pre>LOAD_RESOURCE_HEADER(NovyTyp) {
    NovyTyp _NovyTyp;
    
    /* vlastní naèítání */
    
    rcX = CResourceContainer(this, sResourceName, _NovyTyp);
    return RM_OK;
}</pre>
		</li>
		<br>
		<li>
			Pøidat do souboru <code>ResourceContainer.cpp</code> novou funkci s hlavièkou <code>DESTRUCTOR(NovyTyp)</code>. Tato funkce slouí k uvolnìní nahraného datového typu a je automaticky volána z destruktoru tøídy <a href="#sec7.1.2"><code>CResourceContainer</code></a>:
<pre>DESTRUCTOR(NovyTyp) {
    /* uvolnìní naètenıch dat */
}</pre>
		</li>
	</ul>
	<p>Zbytek funkcí (vèetnì funkce <code>CResourceManager::GetNovyTyp()</code>) a naèítacích mechanismù je tvoøen automaticky pomocí makra <code>EXPAND</code>.</p>

<h2><a name="TerrainGenerator">7.2 Terrain Generator</a></h2>
	<p>TerrainGenerator je konzolovı program pro generování ploch dle zadanıch funkcí a jejich následnı vıstup do souboru. Generování je ovlivnìno celou øadou parametrù, z nich nejpodstatnìjší je monost generování dle vstupního skriptu. Generátor samotnı obsahuje 115 pøeddefinovanıch funkcí - vzorù terénu, ale je moné vyuít skriptu pro vytvoøení nového typu podle vlastní funkce. Program kromì souøadnic vrcholù plochy podmínìnì generuje také normály povrchu ve vygenerovanıch vrcholech a souøadnice pøípadné mapované textury.</p>
	<p>Plocha je generována jako mnoina funkèních hodnot v diskrétní pravoúhlé pravidelné møíce. Rozestupy mezi jednotlivımi body jsou definovány nepøímo - vychází z údaje o velikosti plochy a o poètu segmentù, ze kterıch má  bıt plocha v daném smìru sloena. Dùleitımi údaji pro kadı terén jsou také informace o jeho konvexitì a rovinnosti. Tyto údaje se však nepoèítají, musí bıt specifikovány skriptem (pøípadnì jsou ji pevnì dány definicí typu terénu).</p>

	<h3><a name="sec7.2.1">7.2.1 Vıpoèet normál</a></h3>
		<p>Jedinou èástí generátoru, která je hodna komentáøe, je vıpoèet normál ve vrcholech generovaného terénu. Ten je provádìn na základì prùmìrování normál okolních plošek. Prùmìrování probíhá tak, e se kadá ploška (tou je vdy ètverec díky charakteru pouité sítì) rozdìlí na dva trojúhelníky (u nich je narozdíl od ètvercù zaruèeno, e budou rovinné) a kadému z nich se spoèítá normála jako vektorovı souèin dvou jeho stran. Takto spoètená normála se pak pøiøadí všem vrcholùm daného trojúhelníku. Pøi dìlení ètverce na trojúhelníky se pøiøadí nìkteré vrcholy obìma trojúhelníkùm a nìkteré pouze jednomu z nich. To má za následek, e nìkteré "obdrí" více normál. Z tohoto dùvodu se pøièítají nìkteré normály dvakrát tak, aby kadému vrcholu ètyøúhelníka byly pøiøazeny právì dvì normály. Pøiøazení normály pak obnáší pøiètení pøidávané normály k aktuálnímu souètu normál vrcholu a zvednutí èítaèe poètu normál. Na závìr se souèty normál ve všech vrcholech podìlí jejich èítaèem, èím získáme pøiblinou normálu terénu v daném bodì.</p>
		<p>Uvedenı postup vıpoètu normál je nutnı z toho dùvodu, e ne kadı terén je zadáván derivovatelnou funkcí. Terén je také moné zadat pouze vıškami v jednotlivıch bodech sítì. V takovém pøípadì by se musela nejdøíve nalézt aproximující funkce a ta následnì derivovat. Takovı postup by byl vıraznì sloitìjší jak po stránce implementaèní, tak po stránce vıpoèetní, a vısledek by byl opìt pouze pøiblinı.</p>
	<h3><a name="sec7.2.2">7.2.2 Generování terénu skriptem</a></h3>
		<p>V pøípadì pouití skriptu na generování terénu je danı skript interpretován knihovnou <a href="#ScriptInterpreter">Script Interpreter</a>. Syntaxe skriptù vychází ze syntaxe definované pro <strong>Script Interpreter</strong>, pouze pro generování terénù jsou definovány interní pøíkazy <strong>Terrain Generatoru</strong>, které jsou skriptem volány.</p>
		<ul>
			Pøíkazy Terrain Generatoru pouitelné ve skriptech:
				<li><strong>setFName ( string )</strong>: Nastaví jméno vıstupního souboru.</li>
				<li><strong>setType ( int )</strong>: Nastaví typ pøeliefinovaného plátu.</li>
				<li><strong>setHeight ( float )</strong>: Nastaví vıšku plochy.</li>
				<li><strong>setSegsX ( int )</strong>: Nastaví poèet segmentù na ose X.</li>
				<li><strong>setSegsZ ( int )</strong>: Nastaví poèet segmentù na ose Z.</li>
				<li><strong>setSizeX ( float )</strong>: Nastaví šíøku plochy.</li>
				<li><strong>setSizeZ ( float )</strong>: Nastaví hloubku plochy.</li>
				<li><strong>setNormals ( int )</strong>: Pokud je parametr 1, pak nastaví generování normál na TRUE, jinak FALSE.</li>
				<li><strong>setTextureCoords ( int )</strong>: Pokud je parametr 1, pak nastaví generování souøadnice textury na TRUE, jinak FALSE.</li>
				<li><strong>mkdir ( dirName )</strong>: Pøíkaz mkDir vytvoøí novı adresáø zadaného jména èi cesty.</li>
				<li><strong>createSurfaceDef ( fileName, type, height, segsX, segsZ, sizeX, sizeZ, normals, texture )</strong>: Pøíkaz settings provede nastavení všech parametrù najednou. Typy parametrù i jejich vıznam je odpovídající jednotlivım pøedešlım pøíkazùm.</li>
				<li><strong>settings ( fileName, type, height, segsX, segsZ, sizeX, sizeZ, normals, texture )</strong>: Pøíkaz settings provede nastavení všech parametrù najednou. Typy parametrù i jejich vıznam je odpovídající jednotlivım pøedešlım pøíkazùm.</li>
				<li><strong>generate ()</strong>: Vygeneruje terén podle zadanıch parametrù. Vrací 1 pokud nedošlo k chybì. Nedostává ádnı parametr, vše musí bıt ji nastaveno. Tento pøíkaz slouí k rychlému generování nìkterého z prototypù. Není moné jej pouít v pøípadì vlastního plátu.</li>
				<li><strong>init ()</strong>: Inicializuje struktury potøebné ke generování terénu. Vrací 1, pokud nedošlo k chybì. Struktury jsou vytvoøeny na základì nastavení provedeného pomocí volání settings. Proto pøed voláním init musí bıt ji vše nastaveno.</li>
				<li><strong>computeY ( int X, int Z, float val )</strong>: Nastaví vıšku (Y souøadnici) vrcholu v souøadnicích X,Z na hodnotu val. X a Z jsou souøadnice indexované segmenty, tedy v rozsahu <0,#segmentù>. Nic nevrací. Pøed voláním computeY musí bıt inicializovány nìkteré struktury, tedy zavolán init.</li>
				<li><strong>write ()</strong>: Zapisuje vytvoøenı terén do souboru. Vyuívá ji nastavenıch parametrù a ji vygenerovaného terénu. Opìt je nutné, aby byl døíve zavolán init. Pokud nebyla data správnì naplnìna pomocí volání computeY, program to nepozná, pouze budou špatné vıstupní hodnoty. Vrací 1 v pøípadì úspìšného uloení.</li>
				<li><strong>release ()</strong>: Uvolòuje døíve vytvoøené struktury.</li>
		</ul>
		<p>Vedle struènıch komentáøù k pøíkazùm bude vhodné uvést krátkı pøíklad skriptu, kterı generuje jeden typ terénu:</p>
		<pre>
  #version 1 0
  #cycleinoneblock 0
  
  var ret, size, segs, height, type, lodcount
  var maindir, dir, plateFName, fileName
  
  height = 250
  size = 1000
  lodcount = 6
  maindir = "Terrains"
  plateFName = "normal.grPlate"
  type = 1
  
  call mkdir: ret, maindir
  
  for ind, 115
  {
    type = ind - 1
    segs = 1
    dir = maindir."/Type".type
    call mkdir: ret, dir
    call createSurfaceDef: ret, dir."/".plateFName, type, "Type".type, lodcount
   
    for i,lodcount
    {
      fileName = dir."/".segs.".surface"
      call settings: ret, fileName, type, height, segs, segs, size, size, 1, 1
      call generate: ret
      segs = segs * 2
    }
  }
  
  return ret</pre>

<h2><a name="ScriptInterpreter">7.3 Script Interpreter</a></h2>
	<p><strong>Script Interpreter</strong> je dynamická knihovna interpretující námi navrenı skriptovací jazyk. Je vyuívána jednak døíve popsanou aplikací <a href="#TerrainGenerator">Terrain Generator</a> pro generování terénu podle libovolnıch funkcí, jednak ji vyuívá aplikace <strong>Graphic Test</strong> pro definování pohybu kamery scénou (slouí pro mìøení rychlosti grafického engine). Moduly <a href="graphics.html#GUI">Graphic</a> a <a href="arch_design.html#config_files">Globals</a> vyuívají pouze tøídu <strong>CVariable</strong> pro jednoduchou práci s rùznımi typy promìnnıch. Hlubší vıznam tato knihovna pro hru samotnou nemá, nicménì v pøípadì pøidávání dalších herních módù a modulù by se stala tato knihovna klíèovım prvkem pro snazší definování interaktivních prvkù ve scénì.</p>
	<h3><a name="sec7.3.1">7.3.1 Implementace</a></h3>
		<p>Pøeklad skriptu je zaloen na pøevedení zdrojového kódu na tokeny, které jsou následnì interpretovány podle syntaxe jazyka. Ta je velmi striktní a jednoduchá, take nepøipouští ádné nejednoznaènosti. Jedinou vıjimkou je kontextové chápání promìnnıch, které mohou obsahovat jak øetìzcové, tak èíselné hodnoty. </p>
		<p>Jádrem interpreteru je tøída <strong>CScript</strong>, která obsahuje metody na naètení a interpretaci skriptu. Obsahuje poloky, do nich se skript uloí v podobì seznamu øádek a jejich èástí, a také poloky, v nich je uloen stav (nastavení) direktiv, zásobník programovıch blokù skriptu, strom promìnnıch atd. Podstatné struktury jsou reprezentovány objekty následujících tøíd:</p>
		<ul>
			<li><strong>CVariable</strong> - reprezentuje jednu promìnnou pouitou ve skriptu. Promìnná mùe bıt øetìzec libovolné délky nebo èíselo. Èíslo je reprezentováno jednak jako celoèíselná hodnota, jednak jako hodnota s plovoucí øádovou èárkou. Její interpretace záleí na kontextu, ve kterém se promìnná vyskytuje (pøedevším na pouitém operátoru).</li>
			<li><strong>CScriptLine</strong> - reprezentuje jednu øádku zdrojového kódu skriptu. Syntaxe je definována tak, e kadı pøíkaz leí na samostatné øádce a ukonèen je koncem øádky. <strong>CScriptLine</strong> tedy de facto reprezentuje jeden pøíkaz. Implementována je jako seznam tokenù (instancí tøídy CToken).</li>
			<li><strong>CToken</strong> - pøedstavuje jeden prvek skriptu. Skript je rozdìlen do øádek (resp. pøíkazù) a kadá øádka je posloupností tokenù. Tokenem mùe bıt èíslo, identifikátor, operátor, ... Kadı token má svùj typ a hodnotu. Pøi interpretaci skriptu se interpretují poslouponosti tokenù jako pøíkazy (náznak automatu, kterı pøijímá pouze slova sloená z tokenù dle pravidel gramatiky navreného jazyka).</li>
			<li><strong>OPERATOR</strong> - definuje operátor povolenı v navreném jazyce. Seznam operátorù je pevnì definovanı, seznam instancí této tøídy však umoòují snadnou práci pøi pøekladu - kadı operátor má definovánu prioritu, asociativitu, øetìzec, kterı jej reprezentuje v syntaxi jazyka.</li>
			<li><strong>StackBlock</strong> - reprezentuje blok na zásobníku v dobì interpretace skriptu. Kadı blok mùe mít definovány své lokální promìnné.</li>
		</ul>
		<p>Naètení skriptu ze souboru provádí metoda <strong>Load()</strong>, která naète zvolenı soubor jako posloupnost øádek a na kadou naètenou øádku volá metodu <strong>AddLine()</strong>. Ta provede pøedzpracování naètené øádky - vytvoøí seznam tokenù, urèí, jakého typu øádka je (zda je to pøíkaz, direktiva èi komentáø), pøiøadí jí poøadové èíslo, na které se dá odkazovat, a provede prvotní syntaktickou analızu - kontrolu syntaktické správnosti dané øádky (bez ohledu na okolní kontext).</p>
		<p>Naètenı (a pøedzpracovanı) skript je moné interpretovat metodou <strong>InterpretBlock()</strong>, která má za úkol interpretovat jeden blok kódu. V tomto pøípadì je zavolána na blok uzavírající celı skript. Vstupem této funkci je zásobník programovıch blokù, na jeho vrcholu leí blok urèenı ke zpracování. Block nese informace o tom, na které øádce zaèíná, kde konèí, jaké jsou v nìm definované promìnné. V pøípadì uvedení návratové hodnoty mùe interpretace bloku navrátit hodnotu, toho se vyuívá u pøíkazu <strong>return</strong>, kterı ukonèí interpretaci skriptu a vyvolá navrácení specifikované hodnoty volající funkci.</p>
		<p>Vyhodnocování vırazù je provádìno voláním metod <strong>Evaluate()</strong>, <strong>EvaluateNonBracketed()</strong> a <strong>EvaluateFunction()</strong>. První jmenovaná pøijme seznam tokenù urèenıch k vyhodnocení a zásobník programovıch blokù (kontext programu), aby byla schopna urèit, jaké promìnné jsou v daném místì kódu pouitelné. Prvnì však provede kontrolu závorkování a nalezení nejzanoøenìjšího vırazu bez závorek. Ten vyhodnotí voláním druhé zmínìné metody, která rekurzivnì vyhodnocuje nezávorkované vırazy. Tím probìhne nahrazení podvırazu hodnotou a odstraní se jeden pár závorek. Tento postup se opakuje, dokud vısledkem není jediná hodnota, která je navrácena. Pøi vyhodnocování triviálních vırazù je té pouito poslední zmínìné metody (<strong>EvaluateFunction()</strong>), která vyhodnotí <a href="#sec7.3.3.4">built-in funkci</a>.</p>
		
	<h3><a name="sec7.3.2">7.3.2 Zpùsob uití</a></h3>
		<p>V programu je tøeba vytvoøit instanci tøídy CScript a pomocí funkce <strong>Load()</strong> naèíst a pøedzpracovat skript ze zvoleného souboru skriptu. Poté je moné pøedefinovat nìjaké parametry interpreteru, èím lze potlaèit parametry skriptu nastavené pomocí maker. Naètenı skript se následnì provede zavoláním metody <strong>Interpret()</strong>. Této metodì je nutné pøedat callback funkci, která je volána pro kadı externí pøíkaz (tzv. External Function Call, dále jen EFC) pouitı ve skriptu. O provedení pøíkazu se pak musí postarat volající aplikace v pøedané callback funkci. Tento pøístup umoòuje jednotnou jednoduchou syntaxí docílit zcela odlišnıch efektù v rùznıch programech díky volání jejich vlastních funkcí. Je samozøejmì nutné znát tyto pøíkazy. Mùeme zde uvést ukázku jednoduchého skriptu pouitého v aplikaci Graphic Test pro opakované krouení kamery scénou:</p>
		<pre>
  #version 1 0
  #cycleinoneblock 1
  
  var ret, time, startTime, duration
  var angle, radius, posX, posY, posZ
  
  angle = 0
  duration = 20 * 1000 ; the demo lasts 20 seconds
  radius = 7000
  
  call getTime: ret
  startTime = time = ret
  
  call setLookAtVec: ret, 10000, 0, 10000
  call setUpVec: ret, 0, 1, 0
  
  while time - startTime < duration
  {
    ; compute the position from actual angle
    posY = 3000
    posX = 10000 ++ radius ** cos(angle)
    posZ = 10000 ++ radius ** sin(angle)
    call setEyePtVec: ret, posX, posY, posZ
    call render: ret, 1
    call getTime: ret
    time = ret
    angle = (time - startTime) // 1000 ; compute the angle on the base of actual time
  }
  
  return 0</pre>
  
  <p>Mùete si povšimnout volání externích funkcí <code>setEyePtVec</code> nebo <code>render</code>, které nejsou definovány syntaxí skriptovacího jazyka, ale definují pøíkazy pro danı program.</p>
  
	<h3><a name="sec7.3.3">7.3.3 Syntaxe jazyka</a></h3>
		<p>V následujících odstavcích uvedeme plnou syntaxi navreného skriptovacího jazyka.</p>
		
		<h4><a name="sec7.3.3.1">7.3.3.1 Syntaktické prvky jazyka</a></h4>
			<ul>
				<li><strong>Identifikátory</strong> - pouívané pro jména promìnnıch a pod., mají bìnì uívanou syntax, tedy jsou sloeny z malıch a velkıch písmen (case sensitive!), èísel a znaku podrtrítka (<code>_</code>), pøièem prvním znakem nesmí bıt èíslo.</li>
				<li><strong>Operátory</strong> - pouívané operátory viz odstavec <a href="#sec7.3.3.2">operátory</a>.</li>
				<li><strong>Èísla</strong> - jsou zadávána posloupností cifer, které mùe pøedcházet jeden unární znaménkovı operátor. V pøípadì necelıch èísel je moné uít desetinnou teèku, ta však musí bıt v èísle pouze jedna.</li>
				<li><strong>Øetezce</strong> - jsou zapisovány pomocí úvozovek, tedy "øetìzec". Uvnitø uvozovek je moné pouít libovolnı znak, a na úvozovku a zpìtné lomítko, ty je tøeba zadat escape sekvencí <strong><code>\"</code></strong>, rep. <strong><code>\\</code></strong>.</li>
				<li><strong>Komentáøe</strong> - existují jednak øádkové, tj. komentáø od daného znaku do konce øádky, uvozené znakem støedníku (<code>;</code>). Druhou volbou jsou komentáøe blokové. Ty jsou ohranièeny pomocí sekvencí <code>;-</code> a <code>-;</code>. To je jedinı pøípad, kde není støedník chápán jako komentáø do konce øádky. Blokové komentáøe nejsou hierarchické (první <code>-;</code> ukonèí všechny blokové komentáøe).</li>
				<li><strong>Direktivy</strong> - specifikují chování interpreteru pøi pøekladu. Více v samostatném odstavci <a href="#sec7.3.3.3">direktivy</a>.</li>
				<li><strong>Symboly</strong> - závorky <strong><code>()</code></strong> s jejich bìnou funkcí a sloené závorky <strong><code>{}</code></strong> definující blok programu. Kadou sloenou závorku je tøeba brát jako pøíkaz, proto musí bıt na øádce sama. V nìkterıch pøíkazech jsou pouívány oddìlovaèe <strong><code>,</code></strong> a <strong><code>:</code></strong>. Jakıkoli jinı symbol je interpreterem odmítnut a ohlášen jako chyba.</li>
			</ul>

		<h4><a name="sec7.3.3.2">7.3.3.2 Operátory</a></h4>
			<ul>
				<li><strong><code>+ - *</code></strong> : celoèíselné binární operátory sèítání, odèítání a násobení</li>
				<li><strong><code>/ %</code></strong> : celoèíselné dìlení a modulo</li>
				<li><strong><code>^</code></strong> : celoèíselné umocòování (x^y ~ x<sup>y</sup>)</li>
				<li><strong><code>++ -- ** //</code></strong> : binární operátory nad èísly s plovoucí desetinnou èárkou</li>
				<li><strong><code>.</code></strong> : spojování øetìzcù</li>
				<li><strong><code>==</code></strong> : test na rovnost (vrací 1, pokud jsou si argumenty rovny)</li>
				<li><strong><code>!=</code></strong> : nerovnost</li>
				<li><strong><code>< > <= >=</code></strong> : další porovnávací operátory</li>
				<li><strong><code>||</code></strong> : logické OR</li>
				<li><strong><code>&&</code></strong> : logické AND</li>
				<li><strong><code>!</code></strong> : logické NOT - unární</li>
				<li><strong><code>+ -</code></strong> : unární znaménkové operátory</li>
				<li><strong><code>=</code></strong> : operátor pøiøazení - vrací hodnotu pravého operandu, zároveò však tuto hodnotu ukládá do levého, kterım musí bıt promìnná</li>
			</ul>
			<p>Všechny operátory, a na <strong><code>^</code></strong> a <strong><code>=</code></strong> jsou asociativní zleva. Všechny, a na <strong><code>+</code></strong>, <strong><code>-</code></strong> a <strong><code>!</code></strong> jsou binární. Poøadí vyhodnocování operátorù je následující:</p>
			<ol>
				<li><strong><code>^</code></strong></li>
				<li><strong><code>! + -</code></strong> (unární)</li>
				<li><strong><code>* / ** // %</code></strong></li>
				<li><strong><code>+ - ++ -- .</code></strong></li>
				<li><strong><code>< > <= >=</code></strong></li>
				<li><strong><code>== !=</code></strong></li>
				<li><strong><code>&&</code></strong></li>
				<li><strong><code>||</code></strong></li>
				<li><strong><code>=</code></strong></li>
			</ol>

		<h4><a name="sec7.3.3.3">7.3.3.3 Direktivy</a></h4>
			<p>Direktivy jsou v našem jazyce uvozeny znakem <strong><code>#</code></strong> na zaèátku øádky, pøesnìji:  #identifikator [param1 [,param2 ... ]]. Direktiva ovlivòuje zpùsob interpretace programu. Nìkteré direktivy jsou bezparametrové (pouze flag), jiné mají rùznı poèet parametrù. Seznam direktiv následuje:</p>
			<ul>
				<li><strong>#version a b</strong> - udáva versi interpreteru, kterı je potøeba k pøeloení daného skriptu.</li>
				<li><strong>#cycleinoneblock a</strong> - parametr <strong>a</strong> musí bıt 1 èi 0. Je-li 1, je nastaven flag "cycleinoneblock", kterı má ten vıznam, e cykly, jejich tìlem je blok pøíkazù (ne jedinı pøíkaz), jsou provádìny v jednom bloku, tzn., e není vytváøen a dealokován blok s kadım vstupem do tìla cyklu. Je to rychlejší pøístup, ale v pøípadì, e je uvnitø bloku definována promìnná, dojde k zahlášení chyby "identifier already defined".</li>
				<li><strong>#ignoreefcerror a</strong> - parametr je opìt 1 èi 0. Jde o flag, kterı øíká, zda se mají ignorovat chyby externì volané funkce. Pokud je tedy tato direktiva nastavena, nedojde k ukonèení skriptu pøi chybì v EFC, která mùe mít dopad na ceklové zpracování skriptu a následná volání EFC.</li>
			</ul>
	
		<h4><a name="sec7.3.3.4">7.3.3.4 Built-in funkce</a></h4>
			<p>Interpret jazyka nabízí nìkolik pøeddefinovanıch funkcí, které je moné pouít ve všech skriptech. Jejich seznam následuje:</p>
			<ul>
				<li><strong>sin(x)</strong>, <strong>cos(x)</strong>, <strong>tg(x)</strong>, <strong>arcsin(x)</strong>, <strong>arccos(x)</strong>, <strong>arctg(x)</strong> - goniometrické funkce, parametr je zadáván v radiánech.</li>
				<li><strong>min(a,b)</strong> - vrací hodnotu menšího z argumentù.</li>
				<li><strong>max(a,b)</strong> - vrací hodnotu vìtšího z argumentù.</li>
				<li><strong>sqrt(a)</strong> - druhá odmocnina argumentu.</li>
				<li><strong>length(s)</strong> - vrací délku øetìzce.</li>
				<li><strong>char(s,a)</strong> - vrací znak v zadané pozici øetìzce (indexováno od nuly).</li>
				<li><strong>find(s1,s2)</strong> - vrací pozici prvního vıskytu podøetìzce <strong>s1</strong> v øetìzci <strong>s2</strong>, popøípadì -1, pokud se <strong>s1</strong> v <strong>s2</strong> nenachází.</li>
				<li><strong>substr(s,a,b)</strong> - navrací podøetìzec øetìzce <strong>s</strong> o délce <strong>a</strong> poèínající na pozici <strong>b</strong>.</li>
			</ul>
		
		<h4><a name="sec7.3.3.5">7.3.3.5 Deklarace promìnnıch</a></h4>
			<p>Vytváøení promìnnıch se provádí pøíkazem <strong>var</strong> s následující syntaxí:</p>
				<pre>
  var jmena_prom

  jmena_prom &rarr; jm_prom | jm_prom, jmena_prom | &lambda;
  jm_prom &rarr; identifikator</pre>
			<p>Promìnné jsou vdy inicializovány hodnotou "", tedy prázdnım øetìzcem, resp. èíselnou hodnotou 0. Existence promìnné je v rámci jednoho bloku programu. S ukonèením bloku je promìnná zapomenuta. Promìnné je moné i zastiòovat, ale pouze mezi rùznımi bloky. Pokus o definici promìnné se stejnım jménem, jaké má u jiná promìnná definovaná v tom samém bloku, vede k zahlášení chyby a ukonèení interpretace. Jedinou vıjimkou je definice promìnné v hlavièce cyklu, viz odstavec <a href="#sec7.3.3.7">for cyklus</a>.
		
		<h4><a name="sec7.3.3.6">7.3.3.6 Podmínka</a></h4>
			<p>Podmínka má velice jednoduchou syntax:</p>
			<pre>
  IF_CLAUSE &rarr;
  if expression
  [THEN_CLAUSE]
  [ELSE_CLAUSE]
  
  THEN_CLAUSE &rarr;  
  then expression  
  |  
  then
  {
  commands
  }
  
  ELSE_CLAUSE &rarr;
  else expression
  |
  else
  {
  commands
  }</pre>
  		<p>Jak je vidìt, libovolná ze sekcí then a else mùe chybìt. Tedy i obì zároveò. V takovém pøípadì se vyhodnotí pouze vıraz v hlavièce podmínky a nic dalšího se neprovede. Je tøeba zdùraznit, e <strong>expression</strong> je vıraz, kterı vrací hodnotu. Není však pøíkazem. Proto není moné za then èi else pouít pøíkaz break, continue, return atp! Stejnì tak {} jsou pøíkazem, tedy ani ty nelze pouít tìsnì za then èi else a musí bıt a na dalším øádku, to je však patrné z uvedené syntaxe.

		<h4><a name="sec7.3.3.7">7.3.3.7 Cykly</a></h4>
			<h5>For cyklus</h5>
				<p>For cyklus, tedy cyklus s urèenım poètem opakování, je zde znaènì zjednodušen co se tıèe svého zápisu. Je to proto, e z naší zkušenosti je drtivá vìtšina cyklù provádìna od 0, pøípadnì od jednièky do nìjakého vyššího èísla. Proto jsme chtìli zabránit zbyteènému psaní a for cyklus byl navren takto:</p>
				<pre>
  [FOR] &rarr;
  for jm_prom,count,expression
  |
  for jm_prom,count
  {
  commands
  }
  
  jm_prom &rarr; identifier
  count  &rarr; expression</pre>
  			<p>V pøípadì, e je aplikována první verse, je moné, stejnì jako u podmínky, uít pouze vırazu, tedy ne pøíkazu. Takovıto for cyklus se provádí v tom bloku, v jakém je definován. Druhá verse for cyklu ji vytváøí novı blok. V obou pøípadech je však vytvoøena nová promìnná se jménem <strong>jm_prom</strong>, které je pøiøazena hodnota 1. Pokud daná promìnná v daném bloku ji existuje, je tato pouita a pøedefinována. To je jediná vıjimka, kde nedojde k zahlášení chyby "identifier already defined", a je tu z toho dùvodu, aby bylo moné pouívat jednu promìnnou pro øízení více cyklù po sobì jdoucích. For cyklus je provádìn do té doby, dokud je <strong>jm_prom</strong> menší èi rovno vırazu <strong>count</strong>. Promìnnou je uvnitø tìla cyklu mono mìnit, co bude mít samozøejmì vliv na celkovı poèet iterací. I kdy je pouit druhı zápis, tedy tìlo cyklu tvoøí blok pøíkazù, je promìnná definována ji v tom bloku, kde se for cyklus nachází. To má ten vıznam, e promìnná obsahuje svou hodnotu i poté, co je cyklus ukonèen. V pøípadì, e není ukonèen jinım zpùsobem zevnitø, obsahuje hodnotu vırazu <strong>count</strong>. Pro pøesnou pøedstavu bude dobré naznaèit, jaké pøíkazy se vlastnì provádí:</p>
				<pre>
  var jm_prom 	    ; pozor, zde nemusí dojít k vytvoøení nové
  {
  jm_prom = 1
  if jm_prom > count
  then goto JUMP
  command(s)
  jm_prom = jm_prom + 1
  @JUMP
  }</pre>
  			<p>V pøípadì, e není nastavena direktiva <strong>cycleinoneblock</strong>, je tìlo cyklu (je-li to blok pøíkazù) vytváøeno jako blok pøi kadé iteraci znovu a na konci iterace je znovu zavírán a dealokován. Toto provádìní je pomalejší, ale má ten dùsledek, e uvnitø bloku mùe bıt i definice promìnné, nebo ta je vdy definována v novém bloku znovu. Defaultní nastavení direktivy je na 0.</p>
			<h5>While cyklus</h5>
				<p>While cyklus je cyklus s podmínkou na zaèátku. Jeho syntax je následující:</p>
				<pre>
  WHILE_CLAUSE  &rarr;
  while exp1: exp2
  |
  while exp1
  {
  commands
  }
  
  exp1 &rarr; expression
  exp2 &rarr; expression</pre>
  				<p>Vıznam je zøejmı. Dokud je <strong>exp1</strong> nenulovı, provádìj <strong>exp2</strong>, resp. blok pøíkazù. Opìt platí to, e <strong>exp2</strong> je pouze vıraz, ne pøíkaz. A stejnì jako u for cyklu, i zde záleí na nastavení direktivy <strong>cycleinoneblock</strong>, zda se bude vše provádìt v jednom bloku èi ne.</p>

		<h4><a name="sec7.3.3.8">7.3.3.8 Externall Function Call</a></h4>
			<p>EFC je reprezentováno pøíkazem <strong>call</strong>. Je to jedinı zpùsob, jak komunikovat s volajícím programem za bìhu skriptu (tedy ne pouze skrze návratovou hodnotu). Navíc bez tohoto pøíkazu není schopen skript dìlat nic jiného, ne vyhodnocovat pevnì dané vırazy. Pøíkaz <strong>call</strong> má následující syntax:</p>
			<pre>
  CALL_COMMAND  &rarr;
  call jm_func : jm_prom [param]
  jm_func &rarr; identifier
  jm_prom &rarr; identifier
  param &rarr; expression [, param]</pre>
  		<p>Pøíkaz <strong>call</strong> provede volání funkce, její adresa byla pøedána interpreteru pøi volání funkce <strong>InterpretScript()</strong>. Tato se ji musí postarat jednak o obsluhu danıch parametrù, jednak o návratovou hodnotu. <strong>jm_func</strong> je pøedáno externí funkci jako øetìzec oznaèující jméno funkce, je je volána. Je to pouze parametr, kterı mùe (a nemusí) definovat, co pøesnì po externì volané funkci chceme. Jak jej interpretuje externí program je ji na nìm. Povinná je promìnná <strong>jm_prom</strong>, do které bude uloen návratovı kód externí funkce. Pokud pøi volání externí funkce dojde k chybì (tj. funkce navrátí nenulovou hodnotu interpreteru), interpreter by se mìl zastavit a ukonèit svou práci s chybou v EFC. To je však moné pozmìnit direktivou <strong>ignoreefcerror</strong>. Pokud funkce probìhne v tomto smyslu bez chyby, tj. její návratová hodnota interpreteru je 0, je pøedána návratová hodnota provedeného pøíkazu do zadaného parametru. Tato návratová hodnota ji mùe mít jakıkoli vıznam a je pouze na úrovni komunikace externího programu a skriptu. Opìt mùe hlásit chybu, která kupøíkladu zajistí správnou dealokaci atp.</p>
			<p><strong>param</strong> jsou vırazy, které jsou pøedány dané EF jako parametry. Opìt je pouze na externím programu jak se s nimi vypoøádá. Tìchto parametrù však nesmí bıt více ne kolik uvádí makro <strong>SI_MAX_PARAM_COUNT</strong> definované v souboru ScriptInterpreter.h (prozatím 16, ale lze snadno zmìnit dle potøeb).</p>
	
</body>
</html>
