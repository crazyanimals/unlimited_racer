#include "stdafx.h"
#include "TimeCounter.h"


//////////////////////////////////////////////////////////////////////////////////////////////
// constructor sets the timer precision
//////////////////////////////////////////////////////////////////////////////////////////////
CTimeCounter::CTimeCounter()
{
	timeBeginPeriod( 1 );
}

//////////////////////////////////////////////////////////////////////////////////////////////
// destructor unsets the timer precision
//////////////////////////////////////////////////////////////////////////////////////////////
CTimeCounter::~CTimeCounter()
{
	timeEndPeriod( 1 );
}

//////////////////////////////////////////////////////////////////////////////////////////////
// sets the miliseconds count to 0 and begins counting
//////////////////////////////////////////////////////////////////////////////////////////////
void CTimeCounter::Start()
{
	cMiliSec = 0;
	Active = true;
	startTime = timeGetTime();
	cPausedTime = 0;
	firstPauseTime = 0;
	cPauseCalls = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// pauses the miliseconds counting (useful when app losts exclusive mode or pauses);
// if any count of Pause method was already called and no Continue afterwards,
// this only increases PauseCalls count and lets the Pause state unchanged
//////////////////////////////////////////////////////////////////////////////////////////////
void CTimeCounter::Pause()
{
	// if any count of Pause method was already called and no Continue afterwards,
	// this only increases PauseCalls count and lets the Pause state unchanged
	if ( Active ) 
	{
		Active = false;
		firstPauseTime = timeGetTime();
		cPauseCalls = 0;
	}
	else cPauseCalls++;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// stores the time of last used Pause() call, that's the first unsatisfied with Continue() call
//////////////////////////////////////////////////////////////////////////////////////////////
void CTimeCounter::Continue()
{
	if ( cPauseCalls-- > 0 ) return; // returns immediately, if Pause() was called more times than Continue()
	Active = true;
	cPausedTime += timeGetTime() - firstPauseTime;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// recounts time passed from Start() call on the base of actual time,
// or firstPausedTime if the counter is just paused
//////////////////////////////////////////////////////////////////////////////////////////////
void CTimeCounter::Recount()
{
	if ( Active ) cMiliSec = timeGetTime() - startTime - cPausedTime;
	else cMiliSec = firstPauseTime - startTime - cPausedTime;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// returns time of Start() call
//////////////////////////////////////////////////////////////////////////////////////////////
APPRUNTIME CTimeCounter::GetStartTime()
{
	return startTime;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// returns time passed from calling Start() counted in miliseconds;
// set recount to false to prevent method from recounting time, true is default value
//////////////////////////////////////////////////////////////////////////////////////////////
APPRUNTIME CTimeCounter::GetRunTime(BOOL recount)
{
	if ( recount ) Recount();
	return cMiliSec;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// says whether the timer is active (== not paused)
//////////////////////////////////////////////////////////////////////////////////////////////
BOOL CTimeCounter::IsActive()
{
	return Active;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
